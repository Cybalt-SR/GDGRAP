class Object
!!!133250.cpp!!!	UpdateTransform() : void

	auto newworld_matrix = this->parent_matrix * this->local_matrix;

	for (auto child : this->children)
	{
		child->parent_matrix = newworld_matrix;
		child->UpdateTransform();
	}

	MatToTrans(&this->world, newworld_matrix);
	MatToTrans(&this->local, this->local_matrix);
!!!133378.cpp!!!	MatToTrans(inout target : Transform, in mat : glm::mat4) : void

	glm::vec3 scale;
	glm::quat rotation;
	glm::vec3 translation;
	glm::vec3 skew;
	glm::vec4 perspective;
	glm::decompose(mat, scale, rotation, translation, skew, perspective);

	target->position = translation;
	target->rotation = glm::eulerAngles(rotation) * (180.0f / (float)M_PI);
	target->scale = scale;
	target->Forward = Vector3(mat[2]);
	target->Up = Vector3(mat[1]);
	target->Right = Vector3(mat[0]);
!!!133506.cpp!!!	Copy_self() : Object

	return new Object(*this);
!!!133634.cpp!!!	Object()

	this->parent_matrix = glm::mat4(1.0f);
	this->local_matrix = glm::mat4(1.0f);
	this->parent = nullptr;
!!!133762.cpp!!!	~Object()

	this->SetParent(nullptr);
!!!133890.cpp!!!	Copy() : Object

	auto copy = this->Copy_self();
	copy->children.clear();

	for (auto child : this->children)
	{
		copy->children.push_back(child->Copy());
	}

	return copy;
!!!134018.cpp!!!	World() : Transform

	return &this->world;
!!!134146.cpp!!!	Local() : Transform

	return &this->local;
!!!134274.cpp!!!	SetPosition(in vector : Vector3) : void

	auto world_pos = this->World()->position;

	this->TranslateWorld(-world_pos);
	this->TranslateWorld(vector);
!!!134402.cpp!!!	TranslateWorld(in vector : Vector3) : void

	auto curloc = glm::vec3(this->local_matrix[3]);
	curloc += (glm::vec3)vector;
	auto newrow4 = glm::vec4(curloc, this->local_matrix[3][3]);

	this->local_matrix[3] = newrow4;

	UpdateTransform();
!!!134530.cpp!!!	TranslateLocal(in vector : Vector3) : void

	this->local_matrix = glm::translate(this->local_matrix, (glm::vec3)vector);

	UpdateTransform();
!!!134658.cpp!!!	Rotate(in axis : Vector3, in deg_angle : float) : void

	this->local_matrix = glm::rotate(glm::mat4(1.0f), glm::radians(deg_angle), (glm::vec3)axis) * this->local_matrix;
	UpdateTransform();
!!!134786.cpp!!!	SetRotation(in euler : Vector3) : void

	auto newmat = glm::mat4(1.0f);
	newmat = glm::translate(newmat, (glm::vec3)Local()->position);
	newmat = glm::rotate(newmat, glm::radians(euler.y), glm::vec3(0, 1, 0));
	newmat = glm::rotate(newmat, glm::radians(euler.x), glm::vec3(1, 0, 0));
	newmat = glm::rotate(newmat, glm::radians(euler.z), glm::vec3(0, 0, 1));
	newmat = glm::scale(newmat,(glm::vec3)Local()->scale);

	this->local_matrix = newmat;

	UpdateTransform();
!!!134914.cpp!!!	Orient(in forward : Vector3, in Up : Vector3) : void

	if (abs(forward.SqrMagnitude() - 1.0f) > 0.001f || abs(Up.SqrMagnitude() - 1.0f) > 0.001f) {
		return;
	}

	auto lookatmat = glm::inverse(glm::lookAt((glm::vec3)Vector3::zero, (glm::vec3)forward, (glm::vec3)Up));

	glm::vec3 scale;
	glm::quat rotation;
	glm::vec3 translation;
	glm::vec3 skew;
	glm::vec4 perspective;
	glm::decompose(this->local_matrix, scale, rotation, translation, skew, perspective);

	auto newmat = glm::mat4(1.0f);
	newmat = glm::translate(newmat, translation);
	newmat *= lookatmat;
	newmat = glm::scale(newmat, scale);

	this->local_matrix = newmat;

	UpdateTransform();
!!!135042.cpp!!!	Scale(in vector : Vector3) : void

	this->local_matrix = glm::scale(this->local_matrix, (glm::vec3)vector);

	UpdateTransform();
!!!135170.cpp!!!	SetScale(in vector : Vector3) : void

	glm::vec3 scale;
	glm::quat rotation;
	glm::vec3 translation;
	glm::vec3 skew;
	glm::vec4 perspective;
	glm::decompose(this->local_matrix, scale, rotation, translation, skew, perspective);

	auto newmat = glm::mat4(1.0f);
	newmat = glm::translate(newmat, translation);
	newmat *= glm::toMat4(rotation);
	newmat = glm::scale(newmat, (glm::vec3)vector);

	this->local_matrix = newmat;

	UpdateTransform();
!!!135298.cpp!!!	OnEnterHierarchy(inout newChild : Object) : void

	auto propagate_upwards = [this](Object* object) {
		Object* current = this->parent;

		while (current != nullptr)
		{
			current->OnEnterHierarchy(object);
			current = current->parent;
		}
	};

	propagate_upwards(newChild);
	
	UpdateTransform();
!!!135426.cpp!!!	OnExitHierarchy(inout newChild : Object) : void

	auto propagate_upwards = [this](Object* object) {
		Object* current = this->parent;

		while (current != nullptr)
		{
			current->OnExitHierarchy(object);
			current = current->parent;
		}
	};

	for (auto subchild : newChild->children)
	{
		propagate_upwards(subchild);
	}

	propagate_upwards(newChild);
!!!135554.cpp!!!	GetParent() : Object

	return this->parent;
!!!135682.cpp!!!	SetParent(inout newParent : Object) : void

	if (parent != nullptr) {
		parent->OnExitHierarchy(this);
		parent->children.remove_if([this](Object* child) {return child == this; });
	}

	if (newParent != nullptr) {
		this->CallRecursively([newParent](Object* child) {newParent->OnEnterHierarchy(child); });
		newParent->children.push_back(this);
	}

	this->parent = newParent;
!!!135810.cpp!!!	GetChildAt(in i : size_t) : Object

	auto start = this->children.begin();

	for (int count = 0; count < i; count++)
		++start;

	return *start;
!!!135938.cpp!!!	GetChildCount() : size_t

	return this->children.size();
!!!136066.cpp!!!	Destroy() : void

	this->isDestroyQueued = true;

	for (auto child : this->children) {
		child->Destroy();
	}
!!!136194.cpp!!!	get_isDestroyed() : bool

	return this->isDestroyQueued;
!!!136322.cpp!!!	CallRecursively(in action : std::function<void(Object*)>) : void

	size_t childcount = GetChildCount();
	for (size_t i = 0; i < childcount; i++)
	{
		this->GetChildAt(i)->CallRecursively(action);
	}

	action(this);
